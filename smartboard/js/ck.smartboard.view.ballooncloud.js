// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CK.Smartboard.View.BalloonCloud = (function() {

    function BalloonCloud(wallView) {
      this.render = __bind(this.render, this);

      this.inflateBalloons = __bind(this.inflateBalloons, this);

      this.addLink = __bind(this.addLink, this);

      this.addNode = __bind(this.addNode, this);

      this.startForce = __bind(this.startForce, this);

      this.detectCollision = __bind(this.detectCollision, this);

      this.tick = __bind(this.tick, this);

      this.connectorTransform = __bind(this.connectorTransform, this);

      this.linkDistance = __bind(this.linkDistance, this);

      this.generateForceFunction = __bind(this.generateForceFunction, this);
      console.log("Cloudifying the wall...");
      this.wall = wallView;
      this.nodes = [];
      this.links = [];
      this.vis = d3.select("#" + this.wall.id);
    }

    BalloonCloud.prototype.generateForceFunction = function() {
      return d3.layout.force().charge(0).linkDistance(this.linkDistance).linkStrength(0.2).gravity(0).friction(0.2).size([this.wallWidth, this.wallHeight]).nodes(this.nodes).links(this.links).alpha(0.03).on('tick', this.tick);
    };

    BalloonCloud.prototype.linkDistance = function(link, i) {
      return (link.source.view.$el.outerWidth() / 2 + link.target.view.$el.outerWidth() / 2) + 10;
    };

    BalloonCloud.prototype.connectorTransform = function(d) {
      return "rotate(" + (Math.atan2(d.target.y - d.source.y, d.target.x - d.source.x) * 180 / Math.PI) + "deg)";
    };

    BalloonCloud.prototype.tick = function() {
      var i, q, _i, _ref,
        _this = this;
      this.balloons.style('left', function(d) {
        var balloonWidth;
        balloonWidth = d.view.$el.outerWidth();
        if (d.x + balloonWidth / 2 > _this.wallWidth) {
          d.x = _this.wallWidth - balloonWidth / 2;
        } else if (d.x - balloonWidth / 2 < 0) {
          d.x = 0 + balloonWidth / 2;
        }
        return (d.x - balloonWidth / 2) + 'px';
      }).style('top', function(d) {
        var balloonHeight;
        balloonHeight = d.view.$el.outerHeight();
        if (d.y + balloonHeight / 2 > _this.wallHeight) {
          d.y = _this.wallHeight - balloonHeight / 2;
        } else if (d.y - balloonHeight / 2 < 0) {
          d.y = 0 + balloonHeight / 2;
        }
        return (d.y - balloonHeight / 2) + 'px';
      }).each(function(d) {
        if (d.view.$el.hasClass('pinned')) {
          return d.fixed = true;
        }
      });
      q = d3.geom.quadtree(this.nodes);
      for (i = _i = 0, _ref = this.nodes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        q.visit(this.detectCollision(this.nodes[i]));
      }
      return this.connectors.style("z-index", -1).style("left", function(d) {
        return d.source.x + "px";
      }).style("top", function(d) {
        return d.source.y + "px";
      }).style("width", function(d) {
        var dx, dy;
        dx = d.target.x - d.source.x;
        dy = d.target.y - d.source.y;
        return Math.sqrt(dx * dx + dy * dy) + "px";
      }).style("-webkit-transform", this.connectorTransform).style("-moz-transform", this.connectorTransform).style("transform", this.connectorTransform);
    };

    /*
        corporealizeContribution: (contrib) =>
            unless contrib.id
                console.error("Contribution given to @corporealizeContribution must have an id!")
                throw "Invalid Contribution"
    
            $c = @wall.find('#'+c.id)
            if $c.length is 0
                bubble = new CK.Smartboard.View.ContributionBalloon {model: contrib}
                contrib.on 'change', bubble.render
                $c.view = bubble
            else
                bubble = $c.view
            
            bubble.render()
    
            contrib.index = @nodes.length
            @nodes.push($c)
            @update()
    */


    /*
        corporealizeTag: (tag) =>
            unless tag.id
                console.error("Tag given to @corporealizeTag must have an id!")
                throw "Invalid Tag"
    
    
    
            t = $t[0]
    
            t.index = @nodes.length
            @tags[t.id] = t
            @nodes.push(t)
            @update()
    */


    /*
        # adds links (connectors) to the cloud if they don't already exist
        corporealizeLinks: (c, ts) =>
            if c.jquery
                id = c.attr('id')
                $c = c
            else if c.id
                id = c.id
                $c = @wall.$el.find('#'+id)
            else
                console.error("Contribution given to @addLinks must have an id!")
                throw "Invalid Contribution"
    
            c = $c[0]
    
            unless c
                console.warn "Contibution Balloon for contribution #{id} has not been rendered yet. This shouldn't have happened!"
                return
    
            for t in ts
                if t.jquery
                    id = t.attr('id')
                    $t = t
                else if t.id
                    id = t.id
                    $t = @wall.$el.find('#'+id)
                else
                    console.error("Tag given to @corporealizeTag must have an id!")
                    throw "Invalid Tag"
    
                t = $t[0]
                
                unless t
                    console.warn "Tag Balloon for tag #{id} has not been rendered yet. This shouldn't have happened!"
                    continue
    
                t.contribs? || t.contribs = []
                t.contribs.push(c.id)
                @links.push
                    source: t
                    target: c
    
            @update()
    */


    BalloonCloud.prototype.detectCollision = function(b) {
      var $b, bHeight, bIsTag, bWidth, nx1, nx2, ny1, ny2,
        _this = this;
      $b = b.view.$el;
      bWidth = $b.outerWidth();
      bHeight = $b.outerHeight();
      nx1 = b.x - bWidth / 2;
      nx2 = b.x + bWidth / 2;
      ny1 = b.y - bHeight / 2;
      ny2 = b.y + bHeight / 2;
      bIsTag = $b.hasClass('tag');
      return function(quad, x1, y1, x2, y2) {
        var $q, h, qHeight, qIsTag, qWidth, w, xDist, xNudge, xOverlap, yDist, yNudge, yOverlap;
        if (quad.point && quad.point !== b) {
          qWidth = quad.point.view.$el.outerWidth();
          qHeight = quad.point.view.$el.outerHeight();
          w = bWidth / 2 + qWidth / 2;
          h = bHeight / 2 + qHeight / 2;
          xDist = Math.abs(b.x - quad.point.x);
          yDist = Math.abs(b.y - quad.point.y);
          if (xDist < w && yDist < h) {
            $q = quad.point.view.$el;
            qIsTag = $q.hasClass('tag');
            yOverlap = h - yDist;
            xOverlap = w - xDist;
            if (xDist / w < yDist / h) {
              yNudge = yOverlap / 2;
              if (b.y < quad.point.y) {
                b.y -= yNudge;
                quad.point.y += yNudge;
              } else {
                b.y += yNudge;
                quad.point.y -= yNudge;
              }
            } else {
              xNudge = xOverlap / 2;
              if (b.x < quad.point.x) {
                b.x -= xNudge;
                quad.point.x += xNudge;
              } else {
                b.x += xNudge;
                quad.point.x -= xNudge;
              }
            }
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      };
    };

    BalloonCloud.prototype.startForce = function() {
      if (this.force == null) {
        console.log("Instantiating force...");
        this.force = this.generateForceFunction();
      }
      console.log("Starting force...");
      this.force.start().alpha(0.02);
      return this.balloons.call(this.force.drag);
    };

    BalloonCloud.prototype.addNode = function(n) {
      var b, isNodePublished, t, tag, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
      isNodePublished = n.get('published');
      if (!(n instanceof CK.Model.Contribution) || (n instanceof CK.Model.Contribution && isNodePublished === true)) {
        if (__indexOf.call(this.nodes, n) < 0) {
          this.nodes.push(n);
        }
        if (n instanceof CK.Model.Contribution && n.has('tags')) {
          _ref = n.get('tags');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            t = _ref[_i];
            tag = _.find(this.nodes, function(n) {
              return n.id === t.id;
            });
            if (tag != null) {
              _results.push(this.addLink(n, tag));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        } else if (n instanceof CK.Model.Tag) {
          _ref1 = this.nodes;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            b = _ref1[_j];
            if (b.has('tags') && b.get('tags').some(function(t) {
              return t.id === n.id;
            })) {
              _results1.push(this.addLink(b, n));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }
      }
    };

    BalloonCloud.prototype.addLink = function(fromContribution, toTag) {
      var link;
      link = {
        source: fromContribution,
        target: toTag
      };
      if (__indexOf.call(this.links, link) < 0) {
        return this.links.push(link);
      }
    };

    BalloonCloud.prototype.inflateBalloons = function(balloons) {
      var mode;
      mode = this.wall.mode;
      return balloons.each(function(d, i) {
        var $el, pos, view;
        view = d.view;
        if (!d.view) {
          $el = $('#' + d.id);
          $el.unbind();
          if (d.collectionName === "tags") {
            view = new CK.Smartboard.View.TagBalloon({
              model: d,
              el: $el[0]
            });
          } else if (d.collectionName === "contributions") {
            view = new CK.Smartboard.View.ContributionBalloon({
              model: d,
              el: $el[0]
            });
            if (mode === 'analysis') {
              view.ballonContributionType = view.balloonContributionTypes.minified;
              view.render();
            }
          } else {
            console.error("Unrecognized Balloon type:", d);
          }
          d.view = view;
        }
        view.render();
        if (d.newlyAdded) {
          jQuery('#' + d.id).addClass('new');
          setTimeout(function() {
            return jQuery('#' + d.id).removeClass('new');
          }, 2000);
        }
        pos = view.$el.position();
        if (d.x == null) {
          d.x = pos.left + view.$el.outerWidth() / 2;
        }
        if (d.y == null) {
          return d.y = pos.top + view.$el.outerHeight() / 2;
        }
      });
    };

    BalloonCloud.prototype.render = function(ev) {
      this.wallWidth = this.wall.$el.innerWidth();
      this.wallHeight = this.wall.$el.innerHeight();
      /*
              for n,i in @nodes
                  $n = jQuery(n)
                  pos = $n.position()
                  n.x = pos.left + $n.outerWidth()/2 unless n.x?
                  n.y = pos.top + $n.outerHeight()/2 unless n.y?
      */

      this.vis.selectAll('div.balloon').data(this.nodes).enter().append('div').attr('id', function(d, i) {
        return d.id;
      }).attr('class', "balloon").call(this.inflateBalloons);
      this.balloons = this.vis.selectAll('div.balloon');
      this.vis.selectAll('div.connector').data(this.links).enter().append('div').attr('id', function(d, i) {
        return "" + d.source.id + "-" + d.target.id;
      }).attr('class', 'connector');
      this.connectors = this.vis.selectAll('div.connector');
      return this.startForce();
    };

    return BalloonCloud;

  })();

}).call(this);
