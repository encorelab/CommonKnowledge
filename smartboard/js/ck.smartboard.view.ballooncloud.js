// Generated by CoffeeScript 1.4.0
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CK.Smartboard.View.BalloonCloud = (function() {

    function BalloonCloud(wallView) {
      this.render = __bind(this.render, this);

      this.inflateBalloons = __bind(this.inflateBalloons, this);

      this.addLink = __bind(this.addLink, this);

      this.addNode = __bind(this.addNode, this);

      this.startForce = __bind(this.startForce, this);

      this.detectCollision = __bind(this.detectCollision, this);

      this.tick = __bind(this.tick, this);

      this.connectorTransform = __bind(this.connectorTransform, this);

      this.linkDistance = __bind(this.linkDistance, this);

      this.generateForceFunction = __bind(this.generateForceFunction, this);
      console.log("Cloudifying the wall...");
      this.wall = wallView;
      this.wallWidth = this.wall.$el.innerWidth();
      this.wallHeight = this.wall.$el.innerHeight();
      this.nodes = [];
      this.links = [];
      this.force = this.generateForceFunction();
      this.vis = d3.select("#" + this.wall.id);
    }

    BalloonCloud.prototype.generateForceFunction = function() {
      return d3.layout.force().charge(0).linkDistance(this.linkDistance).linkStrength(0.2).gravity(0).friction(0.2).size([this.wallWidth, this.wallHeight]).nodes(this.nodes).links(this.links).on('tick', this.tick);
    };

    BalloonCloud.prototype.linkDistance = function(link, i) {
      return (link.source.view.$el.outerWidth() / 2 + link.target.view.$el.outerWidth() / 2) + 10;
    };

    BalloonCloud.prototype.connectorTransform = function(d) {
      return "rotate(" + (Math.atan2(d.target.y - d.source.y, d.target.x - d.source.x) * 180 / Math.PI) + "deg)";
    };

    BalloonCloud.prototype.tick = function() {
      var i, q, _i, _ref,
        _this = this;
      this.balloons.style('left', function(d) {
        var balloonWidth;
        balloonWidth = d.view.$el.outerWidth();
        if (d.x + balloonWidth / 2 > _this.wallWidth) {
          d.x = _this.wallWidth - balloonWidth / 2;
        } else if (d.x - balloonWidth / 2 < 0) {
          d.x = 0 + balloonWidth / 2;
        }
        return (d.x - balloonWidth / 2) + 'px';
      }).style('top', function(d) {
        var balloonHeight;
        balloonHeight = d.view.$el.outerHeight();
        if (d.y + balloonHeight / 2 > _this.wallHeight) {
          d.y = _this.wallHeight - balloonHeight / 2;
        } else if (d.y - balloonHeight / 2 < 0) {
          d.y = 0 + balloonHeight / 2;
        }
        return (d.y - balloonHeight / 2) + 'px';
      }).each(function(d) {
        if (d.view.$el.hasClass('pinned')) {
          return d.fixed = true;
        }
      });
      q = d3.geom.quadtree(this.nodes);
      for (i = _i = 0, _ref = this.nodes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        q.visit(this.detectCollision(this.nodes[i]));
      }
      return this.connectors.style("z-index", -1).style("left", function(d) {
        return d.source.x + "px";
      }).style("top", function(d) {
        return d.source.y + "px";
      }).style("width", function(d) {
        var dx, dy;
        dx = d.target.x - d.source.x;
        dy = d.target.y - d.source.y;
        return Math.sqrt(dx * dx + dy * dy) + "px";
      }).style("-webkit-transform", this.connectorTransform).style("-moz-transform", this.connectorTransform).style("transform", this.connectorTransform);
    };

    /*
        corporealizeContribution: (contrib) =>
            unless contrib.id
                console.error("Contribution given to @corporealizeContribution must have an id!")
                throw "Invalid Contribution"
    
            $c = @wall.find('#'+c.id)
            if $c.length is 0
                bubble = new CK.Smartboard.View.ContributionBalloon {model: contrib}
                contrib.on 'change', bubble.render
                $c.view = bubble
            else
                bubble = $c.view
            
            bubble.render()
    
            contrib.index = @nodes.length
            @nodes.push($c)
            @update()
    */


    /*
        corporealizeTag: (tag) =>
            unless tag.id
                console.error("Tag given to @corporealizeTag must have an id!")
                throw "Invalid Tag"
    
    
    
            t = $t[0]
    
            t.index = @nodes.length
            @tags[t.id] = t
            @nodes.push(t)
            @update()
    */


    /*
        # adds links (connectors) to the cloud if they don't already exist
        corporealizeLinks: (c, ts) =>
            if c.jquery
                id = c.attr('id')
                $c = c
            else if c.id
                id = c.id
                $c = @wall.$el.find('#'+id)
            else
                console.error("Contribution given to @addLinks must have an id!")
                throw "Invalid Contribution"
    
            c = $c[0]
    
            unless c
                console.warn "Contibution Balloon for contribution #{id} has not been rendered yet. This shouldn't have happened!"
                return
    
            for t in ts
                if t.jquery
                    id = t.attr('id')
                    $t = t
                else if t.id
                    id = t.id
                    $t = @wall.$el.find('#'+id)
                else
                    console.error("Tag given to @corporealizeTag must have an id!")
                    throw "Invalid Tag"
    
                t = $t[0]
                
                unless t
                    console.warn "Tag Balloon for tag #{id} has not been rendered yet. This shouldn't have happened!"
                    continue
    
                t.contribs? || t.contribs = []
                t.contribs.push(c.id)
                @links.push
                    source: t
                    target: c
    
            @update()
    */


    BalloonCloud.prototype.detectCollision = function(b) {
      var $b, bHeight, bIsTag, bWidth, nx1, nx2, ny1, ny2,
        _this = this;
      $b = b.view.$el;
      bWidth = $b.outerWidth();
      bHeight = $b.outerHeight();
      nx1 = b.x - bWidth / 2;
      nx2 = b.x + bWidth / 2;
      ny1 = b.y - bHeight / 2;
      ny2 = b.y + bHeight / 2;
      bIsTag = $b.hasClass('tag');
      return function(quad, x1, y1, x2, y2) {
        var $q, h, qHeight, qIsTag, qWidth, w, xDist, xNudge, xOverlap, yDist, yNudge, yOverlap;
        if (quad.point && quad.point !== b) {
          qWidth = quad.point.view.$el.outerWidth();
          qHeight = quad.point.view.$el.outerHeight();
          w = bWidth / 2 + qWidth / 2;
          h = bHeight / 2 + qHeight / 2;
          xDist = Math.abs(b.x - quad.point.x);
          yDist = Math.abs(b.y - quad.point.y);
          if (xDist < w && yDist < h) {
            $q = quad.point.view.$el;
            qIsTag = $q.hasClass('tag');
            yOverlap = h - yDist;
            xOverlap = w - xDist;
            if (xDist / w < yDist / h) {
              yNudge = yOverlap / 2;
              if (b.y < quad.point.y) {
                b.y -= yNudge;
                quad.point.y += yNudge;
              } else {
                b.y += yNudge;
                quad.point.y -= yNudge;
              }
            } else {
              xNudge = xOverlap / 2;
              if (b.x < quad.point.x) {
                b.x -= xNudge;
                quad.point.x += xNudge;
              } else {
                b.x += xNudge;
                quad.point.x -= xNudge;
              }
            }
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      };
    };

    BalloonCloud.prototype.startForce = function() {
      this.force.start();
      return this.started = true;
    };

    BalloonCloud.prototype.addNode = function(n) {
      var t, tag, _i, _len, _ref, _results;
      if (__indexOf.call(this.nodes, n) < 0) {
        this.nodes.push(n);
      }
      if (n.has('tags')) {
        _ref = n.get('tags');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          tag = _.find(this.nodes, function(n) {
            return n.id === t.id;
          });
          if (tag != null) {
            _results.push(this.addLink(n, tag));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    BalloonCloud.prototype.addLink = function(fromContribution, toTag) {
      var link;
      link = {
        source: fromContribution,
        target: toTag
      };
      if (__indexOf.call(this.links, link) < 0) {
        return this.links.push(link);
      }
    };

    BalloonCloud.prototype.inflateBalloons = function(balloons) {
      return balloons.each(function(d, i) {
        var view;
        view = d.view;
        if (!d.view) {
          if (d instanceof CK.Model.Tag) {
            view = new CK.Smartboard.View.TagBalloon({
              model: d,
              el: $('#' + d.id)[0]
            });
          } else if (d instanceof CK.Model.Contribution) {
            view = new CK.Smartboard.View.ContributionBalloon({
              model: d,
              el: $('#' + d.id)[0]
            });
          } else {
            console.error("Unrecognized Balloon type:", d);
          }
          d.view = view;
        }
        return view.render();
      });
    };

    BalloonCloud.prototype.render = function(ev) {
      /*
              for n,i in @nodes
                  $n = jQuery(n)
                  pos = $n.position()
                  n.x = pos.left + $n.outerWidth()/2 unless n.x?
                  n.y = pos.top + $n.outerHeight()/2 unless n.y?
      */
      this.balloons = this.vis.selectAll('div.balloon').data(this.nodes).enter().append('div').attr('id', function(d, i) {
        return d.id;
      }).attr('class', "balloon").call(this.inflateBalloons).call(this.force.drag);
      return this.connectors = this.vis.selectAll("div.connector").data(this.links).enter().append("div").attr('id', function(d, i) {
        return "" + d.source.id + "-" + d.target.id;
      }).attr('class', 'connector');
    };

    return BalloonCloud;

  })();

}).call(this);
